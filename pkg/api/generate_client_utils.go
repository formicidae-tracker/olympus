//go:build ignore

package main

import (
	"fmt"
	"log"
	"os"
	"text/template"
)

func main() {
	if err := execute(); err != nil {
		log.Fatalf("could not generate client utils: %s", err)
	}
}

type clientUtilTemplateData struct {
	Clients []string
}

var client_util_templates *template.Template = template.Must(template.New("").Parse(`// Code generated by go generate DO NOT EDIT.

package api

import (
	"context"


	"github.com/sirupsen/logrus"
	"github.com/barkimedes/go-deepcopy"
	grpc "google.golang.org/grpc"
)

{{ range .Clients }}

// {{. -}} Connection holds a connection to an olympus {{.}}
// bi-directional string.
type {{. -}} Connection struct {
	conn        *grpc.ClientConn
	stream      Olympus_ {{- . -}} Client
	acknowledge * {{- . -}} DownStream
}

// Established returns true if connection is established.
func (c * {{- . -}} Connection) Established() bool {
	return c.conn != nil && c.stream != nil
}

// Confirmation returns the {{ . -}} DownStream acknowledgement for the
// olympus server declaration. It can be empty.
func (c * {{- . -}} Connection) Confirmation() * {{- . -}} DownStream {
	return c.acknowledge
}

// ClientConn returns the underlying grpc.ClientConn
func (c * {{- . -}} Connection) ClienConn() *grpc.ClientConn {
	return c.conn
}

// Send sends a {{. -}} UpStream message and gets it {{. -}} DownStream
// response (typically acknowledge).
func (c * {{- . -}} Connection) Send(m * {{- . -}} UpStream) (* {{- . -}} DownStream, error) {
	if c.stream == nil {
		return nil, nil
	}
	err := c.stream.Send(m)
	if err != nil {
		return nil, err
	}
	return c.stream.Recv()
}

// CloseStream close only the bi-directional string, but keeps the tcp
// connection alive. If logger is non-nil, will log any error to it.
func ( c * {{- . -}} Connection) CloseStream(logger *logrus.Entry) {
	var err error
	if logger != nil {
		defer func() {
			if err != nil {
				logger.WithField("error",err).Errorf("could not CloseSend()")
			} else {
				logger.Tracef("CloseSend()")
			}
		}()
	}

	if c.stream != nil {
		err = c.stream.CloseSend()
	}
	c.stream = nil
	c.acknowledge = nil
}

// CloseAll() close completely the {{ . -}} Connection, avoiding any
// leaking routine. If logger is non-nil, will use it to log any
// error.
func (c * {{- . -}} Connection) CloseAll(logger *logrus.Entry) {
	var err error
	if logger != nil {
		defer func() {
			if err != nil {
				logger.WithField("error",err).Errorf("could not CloseAll()")
			} else {
				logger.Tracef("CloseAll()")
			}
		}()
	}

	c.CloseStream(logger)
	if c.conn != nil {
		err = c.conn.Close()
	}
	c.conn = nil
}

// Connect {{- .}} connects a {{ . -}} Connection, to address, potentially
// re-using conn if non-nil.
func Connect {{- . -}} (conn *grpc.ClientConn,
	address string,
	declaration * {{- . -}} Declaration,
	logger *logrus.Entry,
	opts ...grpc.DialOption) (res * {{- . -}} Connection, err error) {

	res = & {{- . -}} Connection{}
	defer func() {
		if err == nil {
			return
		}
		res.CloseAll(logger)
	}()

	if conn == nil {
		dialOptions := append(DefaultDialOptions, opts...)
		if logger != nil {
			logger.WithField("address",address).Infof("dialing")
		}
		res.conn, err = grpc.Dial(address, dialOptions...)
		if err != nil {
			return
		}
	} else {
		res.conn = conn
	}

	client := NewOlympusClient(res.conn)

	res.stream, err = client. {{- . -}} (context.Background(), DefaultCallOptions...)
	if err != nil {
		return
	}
	res.acknowledge, err =  res.Send(& {{- . -}} UpStream{
		Declaration: declaration,
	})
	return
}

// Connect {{- . -}} Async connects a {{ . -}} Connection asynchronously.
func Connect {{- . -}} Async(conn *grpc.ClientConn,
	address string,
	declaration * {{- . -}} Declaration,
	logger *logrus.Entry,
	opts ...grpc.DialOption) (<-chan * {{- . -}} Connection, <-chan error) {

	errors := make(chan error)
	connections := make(chan * {{- . -}} Connection)

	declaration = deepcopy.MustAnything(declaration).(* {{- . -}} Declaration)

	go func() {
		defer close(connections)
		defer close(errors)

		c, err := Connect {{- . -}} (conn,address, declaration, logger, opts...)
		if err != nil {
			select {
			case errors <- err:
			default:
				if logger != nil {
					logger.WithField("error",err).Error("gRPC connection failed after shutdown")
				}
			}
		} else {
			select {
			case connections <- c:
			default:
				if logger != nil {
					logger.Warn("gRPC connection established after shutdown. Closing it")
				}
				c.CloseAll(logger)
			}
		}
	}()

	return connections, errors
}

{{ end }}

`))

func execute() error {
	output_path := "client_utils.pb.go"
	fmt.Printf("Writing '%s'\n", output_path)
	f, err := os.Create(output_path)
	if err != nil {
		return err
	}
	defer f.Close()
	return client_util_templates.Execute(f, clientUtilTemplateData{
		Clients: []string{"Climate", "Tracking"},
	})
}
