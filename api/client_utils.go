// Code generated by go generate DO NOT EDIT.

package api

import (
	"context"
	"log"

	"github.com/barkimedes/go-deepcopy"
	grpc "google.golang.org/grpc"
)

// ZoneConnection holds a connection to an olympus Zone
// bi-directional string.
type ZoneConnection struct {
	conn        *grpc.ClientConn
	stream      Olympus_ZoneClient
	acknowledge *ZoneDownStream
}

// Established returns true if connection is established.
func (c *ZoneConnection) Established() bool {
	return c.conn != nil && c.stream != nil
}

// Confirmation returns the ZoneDownStream acknowledgement for the
// olympus server declaration. It can be empty.
func (c *ZoneConnection) Confirmation() *ZoneDownStream {
	return c.acknowledge
}

// ClientConn returns the underlying grpc.ClientConn
func (c *ZoneConnection) ClienConn() *grpc.ClientConn {
	return c.conn
}

// Send sends a ZoneUpStream message and gets it ZoneDownStream
// response (typically acknowledge).
func (c *ZoneConnection) Send(m *ZoneUpStream) (*ZoneDownStream, error) {
	if c.stream == nil {
		return nil, nil
	}
	err := c.stream.Send(m)
	if err != nil {
		return nil, err
	}
	return c.stream.Recv()
}

// CloseStream close only the bi-directional string, but keeps the tcp
// connection alive. If logger is non-nil, will log any error to it.
func (c *ZoneConnection) CloseStream(logger *log.Logger) {
	if c.stream != nil {
		err := c.stream.CloseSend()
		if err != nil && logger != nil {
			logger.Printf("gRPC CloseSend() failure: %s", err)
		}
	}
	c.stream = nil
	c.acknowledge = nil
}

// CloseAll() close completely the ZoneConnection, avoiding any
// leaking routine. If logger is non-nil, will use it to log any
// error.
func (c *ZoneConnection) CloseAll(logger *log.Logger) {
	c.CloseStream(logger)
	if c.conn != nil {
		err := c.conn.Close()
		if err != nil && logger != nil {
			logger.Printf("gRPC Close() failure: %s", err)
		}
	}
	c.conn = nil
}

// ConnectZone connects a ZoneConnection, to address, potentially
// re-using conn if non-nil.
func ConnectZone(conn *grpc.ClientConn,
	address string,
	declaration *ZoneDeclaration,
	logger *log.Logger,
	opts ...grpc.DialOption) (res *ZoneConnection, err error) {

	res = &ZoneConnection{}
	defer func() {
		if err == nil {
			return
		}
		res.CloseAll(logger)
	}()

	if conn == nil {
		dialOptions := append(DefaultDialOptions, opts...)
		if logger != nil {
			logger.Printf("Dialing '%s'", address)
		}
		res.conn, err = grpc.Dial(address, dialOptions...)
		if err != nil {
			return
		}
	} else {
		res.conn = conn
	}

	client := NewOlympusClient(res.conn)

	res.stream, err = client.Zone(context.Background(), DefaultCallOptions...)
	if err != nil {
		return
	}
	res.acknowledge, err = res.Send(&ZoneUpStream{
		Declaration: declaration,
	})
	return
}

// ConnectZoneAsync connects a ZoneConnection asynchronously.
func ConnectZoneAsync(conn *grpc.ClientConn,
	address string,
	declaration *ZoneDeclaration,
	logger *log.Logger,
	opts ...grpc.DialOption) (<-chan *ZoneConnection, <-chan error) {

	errors := make(chan error)
	connections := make(chan *ZoneConnection)

	declaration = deepcopy.MustAnything(declaration).(*ZoneDeclaration)

	go func() {
		defer close(connections)
		defer close(errors)

		c, err := ConnectZone(conn, address, declaration, logger, opts...)
		if err != nil {
			select {
			case errors <- err:
			default:
				if logger != nil {
					logger.Printf("gRPC connection failed after shutdown: %s", err)
				}
			}
		} else {
			select {
			case connections <- c:
			default:
				if logger != nil {
					logger.Printf("gRPC connection established after shutdown. Closing it")
				}
				c.CloseAll(logger)
			}
		}
	}()

	return connections, errors
}

// TrackingConnection holds a connection to an olympus Tracking
// bi-directional string.
type TrackingConnection struct {
	conn        *grpc.ClientConn
	stream      Olympus_TrackingClient
	acknowledge *TrackingDownStream
}

// Established returns true if connection is established.
func (c *TrackingConnection) Established() bool {
	return c.conn != nil && c.stream != nil
}

// Confirmation returns the TrackingDownStream acknowledgement for the
// olympus server declaration. It can be empty.
func (c *TrackingConnection) Confirmation() *TrackingDownStream {
	return c.acknowledge
}

// ClientConn returns the underlying grpc.ClientConn
func (c *TrackingConnection) ClienConn() *grpc.ClientConn {
	return c.conn
}

// Send sends a TrackingUpStream message and gets it TrackingDownStream
// response (typically acknowledge).
func (c *TrackingConnection) Send(m *TrackingUpStream) (*TrackingDownStream, error) {
	if c.stream == nil {
		return nil, nil
	}
	err := c.stream.Send(m)
	if err != nil {
		return nil, err
	}
	return c.stream.Recv()
}

// CloseStream close only the bi-directional string, but keeps the tcp
// connection alive. If logger is non-nil, will log any error to it.
func (c *TrackingConnection) CloseStream(logger *log.Logger) {
	if c.stream != nil {
		err := c.stream.CloseSend()
		if err != nil && logger != nil {
			logger.Printf("gRPC CloseSend() failure: %s", err)
		}
	}
	c.stream = nil
	c.acknowledge = nil
}

// CloseAll() close completely the TrackingConnection, avoiding any
// leaking routine. If logger is non-nil, will use it to log any
// error.
func (c *TrackingConnection) CloseAll(logger *log.Logger) {
	c.CloseStream(logger)
	if c.conn != nil {
		err := c.conn.Close()
		if err != nil && logger != nil {
			logger.Printf("gRPC Close() failure: %s", err)
		}
	}
	c.conn = nil
}

// ConnectTracking connects a TrackingConnection, to address, potentially
// re-using conn if non-nil.
func ConnectTracking(conn *grpc.ClientConn,
	address string,
	declaration *TrackingDeclaration,
	logger *log.Logger,
	opts ...grpc.DialOption) (res *TrackingConnection, err error) {

	res = &TrackingConnection{}
	defer func() {
		if err == nil {
			return
		}
		res.CloseAll(logger)
	}()

	if conn == nil {
		dialOptions := append(DefaultDialOptions, opts...)
		if logger != nil {
			logger.Printf("Dialing '%s'", address)
		}
		res.conn, err = grpc.Dial(address, dialOptions...)
		if err != nil {
			return
		}
	} else {
		res.conn = conn
	}

	client := NewOlympusClient(res.conn)

	res.stream, err = client.Tracking(context.Background(), DefaultCallOptions...)
	if err != nil {
		return
	}
	res.acknowledge, err = res.Send(&TrackingUpStream{
		Declaration: declaration,
	})
	return
}

// ConnectTrackingAsync connects a TrackingConnection asynchronously.
func ConnectTrackingAsync(conn *grpc.ClientConn,
	address string,
	declaration *TrackingDeclaration,
	logger *log.Logger,
	opts ...grpc.DialOption) (<-chan *TrackingConnection, <-chan error) {

	errors := make(chan error)
	connections := make(chan *TrackingConnection)

	declaration = deepcopy.MustAnything(declaration).(*TrackingDeclaration)

	go func() {
		defer close(connections)
		defer close(errors)

		c, err := ConnectTracking(conn, address, declaration, logger, opts...)
		if err != nil {
			select {
			case errors <- err:
			default:
				if logger != nil {
					logger.Printf("gRPC connection failed after shutdown: %s", err)
				}
			}
		} else {
			select {
			case connections <- c:
			default:
				if logger != nil {
					logger.Printf("gRPC connection established after shutdown. Closing it")
				}
				c.CloseAll(logger)
			}
		}
	}()

	return connections, errors
}
